\chapter{Internal specification}

\section{Nodes and scenes}

To understand the structure of a Godot project, one must understand the concept of \textit{nodes} and \textit{scenes}.
A node represents a single logical part of the application.
For example, a node of the \texttt{MeshInstance3D} type (class) represents the mesh of a 3D object.
A node may have a script attached to extend its functionality.
To be attached to a node, the script must extend the right class.
A script attached to a \texttt{MeshInstance3D} node should extend the \texttt{MeshInstance3D} class or any class that is more general.
For \texttt{MeshInstance3D}, this could be the general \texttt{Node3D} class.
A script may be given a class name to create a user-defined class.
A node can have multiple children, creating a tree structure.

A scene is a tree of nodes which can be instantiated multiple times.
For instance, a simple scene representing a 3D object may be composed of an \texttt{Area3D} as the root node with a \texttt{CollisionShape3D} and a \texttt{MeshInstance3D} as its children.
Such a scene scene would represent a 3D object which has a mesh and a collider.

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.5]{graf/single_node}
    \caption{A single \texttt{MeshInstance3D} node.}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.5]{graf/simple_scene}
    \caption{A simple 3D object scene. The red node is the root node of the scene.}
    \label{simple_scene}
\end{figure}

\section{GeoApp structure}

As with any Godot project, the \texttt{root} node is the top-level node which contains the entirety of the application.
In this project, the root node contains two logical parts.
The first and most important part is the \texttt{Main} scene.
The other part are the \textit{autoloads}.

\section{The Main scene}

The \texttt{Main} scene represents the whole UI of the application.
It is composed of all of the UI screens.
One of its children is the background of the application.
Figure \ref{main_scene} shows the structure of the \texttt{Main} scene.

\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth]{graf/main_scene}
    \caption{The Main scene.}
    \label{main_scene}
\end{figure}

The ellipses represent nodes, while rectangles represent scenes.
The \texttt{Main} node has a script attached.
The script controls transitions between screens.
Each screen scene has a script attached.
A screen's script is responsible for the internal logic of the screen.

\section{Autoloads}

% TODO: jakas cytacja do design patternow?
Autoloads are Godot's implementation of the singleton design pattern.
An autoload is a node which is loaded when the application starts.
The members of an autoload are accessible from every node in the scene tree.
The autoloads used in GeoApp are:
\begin{itemize}
    \item \texttt{Global} - contains utility functions related to rounding of floating-point values and clearing of UI grids.
    \item \texttt{Poly} - contains the predefined vertices of certain polyhedrons and functions related to polyhedrons.
    \item \texttt{Settings} - contains all of the application's settings and functions for storing and loading them.
    \item \texttt{Tasks} - is responsible for loading all of the tasks.
\end{itemize}

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.5]{graf/app_structure}
    \caption{The complete application structure starting from the \texttt{root} node.}
    \label{app_structure}
\end{figure}

\section{Signals}

Signals are Godot's implementation of the Observer design pattern.
Each node defines a set of signals.
These signals can be connected to a node's method.
This node may be any node in the scene tree, including the node which exposes the signal.
The method is called when the signal is emitted.
A signal is emitted when the action associated with it happens.

For example, a \texttt{Button} node's \texttt{pressed} signal is emitted when the button is pressed.
The signal may be connected to a \texttt{\_on\_button\_pressed} method which will be called whenever the button is pressed.
The script containing the \texttt{\_on\_button\_pressed} method may be attached to any node, including the button itself.

Signals allow for loose coupling between nodes.
A node does not have to know where it is in the scene tree when communication with it is handled using signals.

\section{Representation of solids}

Each solid in the application is represented by a scene.
The structure of the scene similiar to the one in figure \ref{simple_scene}.
The difference is that the type of the root node is a class which inherits from the custom \texttt{Figure} class.
For example, the root node of the cube scene if of the \texttt{Cube} type.

\subsection{Figure}

The \texttt{Figure} class is the base class of each solid.
It:
\begin{itemize}
    \item Stores the mesh and the collision shape,
    \item Handles behavior that is triggered when the solid is hovered,
    \item Contains the \texttt{area} and \texttt{volume} methods,
    \item Emits signals when the properties of the solid change.
\end{itemize}

\subsection{Polyhedron}

The \texttt{Polyhedron} class extends the \texttt{Figure} class.
It represents a convex polyhedron.
The class handles the additional vertex and edge objects.
The class handles the additional objects that are spawned alogside the main body of the polyhedron.
Those objects are the spheres on the vertices and cylinders on the edges.
The class implements \texttt{Figure}'s \texttt{area} and \texttt{volume} methods to calculate these properties for any polyhedron.

\subsubsection{Area}

The total area of a polyhedron can be calculated as the sum of the areas of all faces.
A face of a valid polyhedron\footnote{This refers to valid polyhedron as defined in section \ref{poly_valid}} is a convex polygon.
A convex polygon can be decomposed into a set of triangles.
If the polygon is defined a list of vertices lying on a plane, the face can be decomposed by fixing one vertex and creating triangles from pairs of adjacent vertices.
The area of each triangle is calculated using the magnitude of the cross product of two edge vectors.
For a triangle with vertices $v_1$, $v_2$, and $v_3$, its area $A$ is calculated as:
\begin{equation}
    A = \frac{1}{2} \left\| (v_2 - v_1) \times (v_3 - v_1) \right\|.
\end{equation}
The total face area is the sum of the areas of all triangles.

\begin{algorithm}[H]
\caption{Face area computation}
\begin{algorithmic}
\State $area \gets 0$
\For{$i \gets 1$ to $n - 2$}
    \State $v_1 \gets vertices[0]$
    \State $v_2 \gets vertices[i]$
    \State $v_3 \gets vertices[i+1]$
    \State $area \gets area + \frac{1}{2} \left\| (v_2 - v_1) \times (v_3 - v_1) \right\|$
\EndFor
\State \Return $area$
\end{algorithmic}
\end{algorithm}

\subsubsection{Volume}

The volume of a polyhedron can be calculated by dividing it into pyramids.
For each face of the polyhedron, the algorithm computes the volume of the pyramid associated with the face.
The base of the pyramid is the corresponding face.
Let $q$ be any of the face's vertices, $n$ the surface normal of the face and $A$ the surface area of the face.
The dot product of $q$ and $n$ is equal to the pyramid's height.
The volume $V_P$ of the pyramid is given by the formula:
\begin{equation}
    V_P = \frac{1}{3}(q \cdot n) \cdot A
\end{equation}
The total volume of the polyhedron is the sum of all of the pyramid volumes.
This approach assumes that the polyhedron is closed and that all face normals point outward.

\begin{algorithm}[H]
\caption{Polyhedron volume computation}
\begin{algorithmic}
\State $V \gets 0$
\For{each face $f$ in faces}
    \State Select three vertices $v_1$, $v_2$, $v_3$ from $f$
    \State $n \gets \text{normalize}((v_3 - v_1) \times (v_2 - v_1))$
    \State $A \gets \text{area}(f)$
    \State $q \gets v_1$
    \State $V \gets V + \frac{1}{3}(q \cdot n) \cdot A$
\EndFor
\State \Return $V$
\end{algorithmic}
\end{algorithm}

\section{Tasks}

Each task is a scene whose root node is of a type derived from the \texttt{Task} class.
The \texttt{Task} class defines methods for the task difficulty, description, parameters and steps.
Each derived task class then overrides those methods to create a unique task.
The only children of the task scene's root node are the the solids that make up the task.

\begin{figure}[hb]
    \centering
    \includegraphics[width=\textwidth]{graf/tasks_diagram}
    \caption{Task class diagram. Less important class members were omitted for conciseness.}
    \label{tasks_diagram}
\end{figure}

\section{User interface}

User interface in Godot is created with the use of \texttt{Control} nodes.
Contol nodes used in GeoApp may be split into three categories: containers, interactive elements and labels.
Containers contain other UI elements and are responsible for their layout.
They are nodes that derive from the \texttt{Container} class.
There are many types of containers.
Each type of container lays out its children in a different way.
For instance, the \texttt{HBoxContainer} lays out its children horizontally.
The \texttt{HBoxContainer} container lays out its children vertically.
Other types of containers include the \texttt{GridContainer} and \texttt{ScrollContainer}.

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.33]{graf/hbox_layout}
    \caption{A \texttt{Button}, \texttt{Label} and \texttt{SpinBox} in a \texttt{HBoxContainer}.}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.33]{graf/vbox_layout}
    \caption{The same nodes in a \texttt{VBoxContainer}.}
\end{figure}

Interactive elements allow the user to interact with the application.
They define signals which are emitted when the user iteracts with them.
The two main interactive elements in GeoApp are the \texttt{Button} and \texttt{SpinBox} nodes.
The \texttt{Button} node exposes the \texttt{pressed} signal which is emitted when the button is pressed.
The \texttt{SpinBox} node exposes the \texttt{value\_changed} signal which is emitted when the value inside of the spin box changes.

Labels are non-interactive elements which display text.
The text can be changed dynamically.
Labels are represented by two nodes: \texttt{Label} and \texttt{RichTextLabel}.
\texttt{Label} is the simpler of the two.
It allows for displaying text without additional formatting.
\texttt{RichTextLabel} allow the text to be formatted with the BBCode markup language \cite{bbcode}.
BBCode allows sections of the text to be bolded, italicized or underlined.
It also allows other format specifiers.

% \section{The 3D view}
%
% The 3D view is represented by two classes derived from the built-in \texttt{WorldEnvironment} class.
% The \texttt{WorldEnvironment} class is used to configure the environment of a 3D scene.
% In the task exploration and task solving modules, the 3D view is represented by the \texttt{TaskEnvironment} class.
% In the playground module, the 3D view is represented by the \texttt{PolyhedronEnvironment} class.
% These class provides functionality related to loading the task or polyhedron present in the environment.

\section{Polyhedron files}

Polyhedron files store polyhedrons used in the playground module.
They are introduced in section \ref{poly_files}.
This section explains their internal structure.

Polyhedron files store their content in the JSON (JavaScript Object Notation) format \cite{json}.
The file stores a JSON array of vertex objects.
A vertex object is a JSON object with name-value pairs defined in table \ref{vertex_object_fields}.
A vertex object can contain other name-value pairs.
Name-value pairs other than the expected ones will be ignored.

\begin{table}[ht]
    \centering
    \caption{Name-value pairs of a valid vertex JSON object.}
    \label{vertex_object_fields}
    \begin{tabular}{|l|l|l|}
        \hline
        Name & Value & Note \\
        \hline
        \hline
        \textit{name} & string & The name of the vertex \\
        \hline
        \textit{x} & number & The x coordinate of the vertex \\
        \hline
        \textit{y} & number & The y coordinate of the vertex \\
        \hline
        \textit{z} & number & The z coordinate of the vertex \\
        \hline
    \end{tabular}
\end{table}

\newpage

\begin{lstlisting}[basicstyle=\ttfamily, showstringspaces=false, caption=The content of a polyhedron file containing two vertices.]
[
  {
    "name": "Vertex 1",
    "x": -1.0,
    "y": 0.0,
    "z": 0.0
  },
  {
    "name": "Vertex 2",
    "x": 1.0,
    "y": 0.0,
    "z": 0.0
  }
]
\end{lstlisting}

\section{Project file structure}

Godot does not enforce a strict file structure.
Any file can be placed anywhere in the project directory or its subdirectories.
Despite that, files were organized into subdirectories to group them logically and reduce the size of the main directory.
The project directory is divided into three subdirectories: \texttt{assets}, \texttt{scenes} and \texttt{scripts}.
Visually, the project file structure looks like:
\dirtree{%
.1 GeoApp.
.2 assets.
.2 scenes.
.2 scripts.
}

\begin{itemize}
    \item \texttt{assets} contains non-code resources used by the application, such as icons, and the application's theme.
    \item \texttt{scenes} contains Godot scene files, which define the structure and composition of the user interface and 3D objects.
    Each scene represents a self-contained part of the application.
    \item \texttt{scripts} contains script files implementing the application logic, including input hanlding and geometric calculations.
\end{itemize}
This structure improves clarity and simplifies project navigation.

% \begin{itemize}
% \item concept of the system
% \item system architecture
% \item description of data structures (and data bases)
% \item components, modules, libraries, resume of important classes (if used)
% \item resume of important algorithms (if used)
% \item details of implementation of selected parts
% \item applied design patterns
% \item UML diagrams
% \end{itemize}



% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% To use the minted package, import the package:                    %
% \usepackage{minted}                                               %
% and compile with the shell escape                                 %
% pdflatex -shell-escape main                                       %
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 


% Use special environments for inline code, eg  \lstinline|int a;| (package \texttt{listings})% or  \mintinline{C++}|int a;| (package \texttt{minted})
% . Longer parts of code put in the figure environment, eg. code in Fig. \ref{fig:pseudocode:listings}% and Fig. \ref{fig:pseudocode:minted}
% . Very long listingsâ€“move to an appendix.
%
%
% \clearpage
% \begin{figure}
% \centering
% \begin{lstlisting}
% class test : public basic
% {
%     public:
%       test (int a);
%       friend std::ostream operator<<(std::ostream & s, 
%                                      const test & t);
%     protected:
%       int _a;  
%
% };
% \end{lstlisting}
% \caption{Pseudocode in \texttt{listings}.}
% \label{fig:pseudocode:listings}
% \end{figure}

%\begin{figure}
%\centering
%\begin{minted}[linenos,frame=lines]{c++}
%class test : public basic
%{
%    public:
%      test (int a);
%      friend std::ostream operator<<(std::ostream & s, 
%                                     const test & t);
%    protected:
%      int _a;  
%      
%};
%\end{minted}
%\caption{Pseudocode in \texttt{minted}.}
%\label{fig:pseudocode:minted}
%\end{figure}


