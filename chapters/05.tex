\chapter{Internal specification}

\section{Nodes and scenes}

To understand the structure of a Godot project, one must understand the concept of \textit{nodes} and \textit{scenes}.
A node represents a single logical part of the application.
For example, a node of the \texttt{MeshInstance3D} type (class) represents the mesh of a 3D object.
A node may have a script attached to extend its functionality.
To be attached to a node, the script must extend the right class.
A script attached to a \texttt{MeshInstance3D} node should extend the \texttt{MeshInstance3D} class or any class that is more general.
For \texttt{MeshInstance3D}, this could be the general \texttt{Node3D} class.
A script may be given a class name to create a user-defined class.
A node can have multiple children, creating a tree structure.

A scene is a tree of nodes which can be instantiated multiple times.
For instance, a simple scene representing a 3D object may be composed of an \texttt{Area3D} as the root node with a \texttt{CollisionShape3D} and a \texttt{MeshInstance3D} as its children.
Such a scene scene would represent a 3D object which has a mesh and a collider.

\newpage

\section{GeoApp structure}

As with any Godot project, the \texttt{root} node is the top-level node which contains the entirety of the application.
In this project, the root node contains two logical parts.
The first and most important part is the \texttt{Main} scene.
The other part are the \textit{autoloads}.
Figure \ref{app_structure} shows the complete structure of the application.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{graf/app_structure}
    \caption{The complete application structure starting from the \texttt{root} node.}
    \label{app_structure}
\end{figure}

\section{The Main scene}

The \texttt{Main} scene represents the whole UI of the application.
It is composed of all of the UI screens.
One of its children is the background of the application.
Figure \ref{main_scene} shows the structure of the \texttt{Main} scene.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{graf/main_scene}
    \caption{The Main scene.}
    \label{main_scene}
\end{figure}

The ellipses represent nodes, while rectangles represent scenes.
The \texttt{Main} node has a script attached.
The script controls transitions between screens.
Each screen scene has a script attached.
A screen's script is responsible for the internal logic of the screen.

\section{Autoloads}

Autoloads are Godot's implementation of the Singleton design pattern \cite{gamma1994design}.
The Singleton pattern ensures that a class has exactly one instance and provides a global point of access to it.
In the application, autoloaded scripts are used to store shared state and functionality that must be accessible from multiple scenes.
The autoloads used in GeoApp are:
\begin{itemize}
    \item \texttt{Global} - contains utility functions related to rounding of floating-point values and clearing of UI grids.
    \item \texttt{Poly} - contains the predefined vertices of certain polyhedrons and functions related to polyhedrons.
    \item \texttt{Settings} - contains all of the application's settings and functions for storing and loading them.
    \item \texttt{Tasks} - is responsible for loading all of the tasks.
\end{itemize}

\section{Signals}

Signals are Godot's implementation of the observer design pattern \cite{freeman2020head}.
The Observer pattern defines a one-to-many dependency between objects, where changes in one object automatically notify and update dependent objects.
Signals are used in the application to decouple user interface elements from application logic.

Each node defines a set of signals.
These signals can be connected to a script's method.
The method is called when the signal is emitted.
A signal is emitted when the action associated with it happens.
For example, a \texttt{Button} node's \texttt{pressed} signal is emitted when the button is pressed.
The signal may be connected to a \texttt{\_on\_button\_pressed} method which will be called whenever the button is pressed.
The script containing the \texttt{\_on\_button\_pressed} method may be attached to any node, including the button itself.

Signals allow for loose coupling between nodes.
A node does not have to know where it is in the scene tree when communication with it is handled using signals.

\section{Representation of solids}

Each solid in the application is represented by a scene.
The structure of the scene is similar to the one in figure \ref{simple_scene}.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{graf/simple_scene}
    \caption{A simple 3D object scene. The red node is the root node of the scene.}
    \label{simple_scene}
\end{figure}

The difference is that the type of the root node is a class which inherits from the custom \texttt{Figure} class.
For example, the root node of the cube scene is of the \texttt{Cube} type.

\subsection{Figure}

The \texttt{Figure} class is the base class of each solid.
It:
\begin{itemize}
    \item Stores the mesh and the collision shape.
    \item Handles behavior that is triggered when the solid is hovered.
    \item Contains the \texttt{area} and \texttt{volume} methods.
    \item Emits signals when the properties of the solid change.
\end{itemize}

\subsection{Polyhedron}

The \texttt{Polyhedron} class extends the \texttt{Figure} class.
It represents a convex polyhedron.
The class handles the additional vertex and edge objects.
The class handles the additional objects that are spawned alongside the main body of the polyhedron.
Those objects are the spheres on the vertices and cylinders on the edges.
The class implements \texttt{Figure}'s \texttt{area} and \texttt{volume} methods to calculate these properties for any polyhedron.

\subsubsection{Area}

The total area of a polyhedron can be calculated as the sum of the areas of all faces.
A face of a valid polyhedron\footnote{This refers to valid polyhedron as defined in section \ref{poly_valid}} is a convex polygon.
A convex polygon can be decomposed into a set of triangles.
If the polygon is defined a list of vertices lying on a plane, the face can be decomposed by fixing one vertex and creating triangles from pairs of adjacent vertices.
The area of each triangle is calculated using the magnitude of the cross product of two edge vectors.
For a triangle with vertices $v_1$, $v_2$, and $v_3$, its area $A$ is calculated as:
\begin{equation}
    A = \frac{1}{2} \left\| (v_2 - v_1) \times (v_3 - v_1) \right\|.
\end{equation}
The total face area is the sum of the areas of all triangles.
Algorithm \ref{area_computation} shows the algorithm used to calculate the area of one polyhedron face.

\begin{algorithm}[H]
    \caption{Face area computation}
    \begin{algorithmic}
    \State $area \gets 0$
    \For{$i \gets 1$ to $n - 2$}
        \State $v_1 \gets vertices[0]$
        \State $v_2 \gets vertices[i]$
        \State $v_3 \gets vertices[i+1]$
        \State $area \gets area + \frac{1}{2} \left\| (v_2 - v_1) \times (v_3 - v_1) \right\|$
    \EndFor
    \State \Return $area$
    \end{algorithmic}
    \label{area_computation}
\end{algorithm}

\subsubsection{Volume}

The volume of a polyhedron can be calculated by dividing it into pyramids \cite{poly_volume}.
For each face of the polyhedron, the algorithm computes the volume of the pyramid associated with the face.
Let $q$ be any of the face's vertices, $n$ the surface normal of the face, and $A$ the surface area of the face.
The volume $V_P$ of the pyramid is given by the formula:
\begin{equation}
    V_P = \frac{1}{3}(q \cdot n) \cdot A.
\end{equation}
The total volume of the polyhedron is the sum of all of the pyramid volumes.
This approach assumes that the polyhedron is closed and that all face normals point outward.
Algorithm \ref{volume_computation} shows the algorithm used to calculate the volume of a polyhedron.

\begin{algorithm}[H]
    \caption{Polyhedron volume computation}
    \begin{algorithmic}
    \State $V \gets 0$
    \For{each face $f$ in faces}
        \State Select three vertices $v_1$, $v_2$, $v_3$ from $f$
        \State $n \gets \text{normalize}((v_3 - v_1) \times (v_2 - v_1))$
        \State $A \gets \text{area}(f)$
        \State $q \gets v_1$
        \State $V \gets V + \frac{1}{3}(q \cdot n) \cdot A$
    \EndFor
    \State \Return $V$
    \end{algorithmic}
    \label{volume_computation}
\end{algorithm}

\section{Tasks}

Each task is a scene whose root node is of a type derived from the \texttt{Task} class.
The \texttt{Task} class defines methods for the task difficulty, description, parameters, and steps.
Each derived task class then overrides those methods to create a unique task.
The only children of the task scene's root node are the solids that make up the task.
Figure \ref{tasks_diagram} shows the diagram of the \texttt{Task} class, classes derived from it, and other related classes.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{graf/tasks_diagram}
    \caption{Task class diagram. Less important class members were omitted for conciseness.}
    \label{tasks_diagram}
\end{figure}

Each class derived from \texttt{Task} (excluding \texttt{CubeTaskBase} and \texttt{PrismTaskBase}) corresponds to a task.
For example, \texttt{StackedCubesTask} corresponds to the \textit{Stacked Cubes} task. \texttt{PrismTaskMediumPrecision} corresponds to the \textit{Prism With Decimal Digits} task.
Additionally:

\begin{itemize}
    \item \texttt{TaskFloatValue} represents a task parameter.
        Each instance specifies the current, minimum, and maximum value as well the precision with which the value is randomly picked.
    \item \texttt{Step} represents a single task step.
    % \item \texttt{Task} is the base class for all tasks.
    \item \texttt{CubeTaskBase} is the base class of \texttt{CubeTask} and \texttt{CubeTaskMediumPrecision}.
        It stores the cube which is used by all of its subclasses.
        The subclasses differ in the precision of their task parameters.
    \item \texttt{PrismTaskBase} is the base class of \texttt{PrismTask} and \texttt{PrismTaskMediumPrecision}.
        It stores the prism which is used by all of its subclasses.
        The subclasses differ in the precision of their task parameters.
    % \item \texttt{CuboidTask} corresponds to the \textit{Cuboid} task.
    % \item \texttt{HexagonalPyramidTask} corresponds to the \textit{Hexagonal Pyramid} task.
    % \item \texttt{PyramidTask} corresponds to the \textit{Pyramid} task.
    % \item \texttt{PyramidAreaTask} corresponds to the \textit{Pyramid Area} task.
    %     It uses the same task parameters but overrides the \texttt{steps} method.
    \item \texttt{PyramidAreaTask} uses the same task parameters as \texttt{PyramidTask} but overrides the \texttt{steps} method.
    % \item \texttt{StackedCubesTask} corresponds to the \textit{Stacked Cubes} task.
\end{itemize}

\section{User interface}

User interface in Godot is created with the use of \texttt{Control} nodes.
Control nodes used in GeoApp may be split into three categories: containers, interactive elements, and labels.
Containers contain other UI elements and are responsible for their layout.
They are nodes that derive from the \texttt{Container} class.
There are many types of containers.
Each type of container lays out its children in a different way.
For instance, the \texttt{HBoxContainer} lays out its children horizontally (see figure \ref{hbox}).
The \texttt{VBoxContainer} container lays out its children vertically (see figure \ref{vbox}).
Other types of containers include the \texttt{GridContainer} and \texttt{ScrollContainer}.

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.33]{graf/hbox_layout}
    \caption{A \texttt{Button}, \texttt{Label}, and \texttt{SpinBox} in a \texttt{HBoxContainer}.}
    \label{hbox}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.33]{graf/vbox_layout}
    \caption{The same nodes in a \texttt{VBoxContainer}.}
    \label{vbox}
\end{figure}

Interactive elements allow the user to interact with the application.
They define signals which are emitted when the user interacts with them.
The two main interactive elements in GeoApp are the \texttt{Button} and \texttt{SpinBox} nodes.
The \texttt{Button} node exposes the \texttt{pressed} signal which is emitted when the button is pressed.
The \texttt{SpinBox} node exposes the \texttt{value\_changed} signal which is emitted when the value inside of the spin box changes.

Labels are non-interactive elements which display text.
The text can be changed dynamically.
Labels are represented by two nodes: \texttt{Label} and \texttt{RichTextLabel}.
\texttt{Label} is the simpler of the two.
It allows for displaying text without additional formatting.
\texttt{RichTextLabel} allow the text to be formatted with the BBCode (Bulletin Board Code) markup language \cite{bbcode}.
BBCode allows sections of the text to be bolded, italicized or underlined.
It also allows other format specifiers.

% \section{The 3D view}
%
% The 3D view is represented by two classes derived from the built-in \texttt{WorldEnvironment} class.
% The \texttt{WorldEnvironment} class is used to configure the environment of a 3D scene.
% In the task exploration and task solving modules, the 3D view is represented by the \texttt{TaskEnvironment} class.
% In the playground module, the 3D view is represented by the \texttt{PolyhedronEnvironment} class.
% These class provides functionality related to loading the task or polyhedron present in the environment.

\section{Polyhedron files}

Polyhedron files store polyhedrons used in the playground module.
They are introduced in section \ref{poly_files}.
This section explains their internal structure.

Polyhedron files store their content in the JSON (JavaScript Object Notation) format \cite{json}.
The file stores a JSON array of vertex objects.
A vertex object is a JSON object with name-value pairs defined in table \ref{vertex_object_fields}.
A vertex object can contain other name-value pairs.
Name-value pairs other than the expected ones will be ignored.
Listing \ref{sample_poly} contains the content of a polyhedron file which stores two vertices.

\begin{table}[ht]
    \centering
    \caption{Name-value pairs of a valid vertex JSON object.}
    \label{vertex_object_fields}
    \begin{tabular}{|l|l|l|}
        \hline
        Name & Value & Note \\
        \hline
        \hline
        \textit{name} & string & The name of the vertex \\
        \hline
        \textit{x} & number & The x coordinate of the vertex \\
        \hline
        \textit{y} & number & The y coordinate of the vertex \\
        \hline
        \textit{z} & number & The z coordinate of the vertex \\
        \hline
    \end{tabular}
\end{table}

% \newpage

\begin{lstlisting}[basicstyle=\ttfamily, showstringspaces=false, caption=The content of a polyhedron file containing two vertices., label=sample_poly]
[
  {
    "name": "Vertex 1",
    "x": -1.0,
    "y": 0.0,
    "z": 0.0
  },
  {
    "name": "Vertex 2",
    "x": 1.0,
    "y": 0.0,
    "z": 0.0
  }
]
\end{lstlisting}

\section{Project file structure}

Godot does not enforce a strict file structure.
Any file can be placed anywhere in the project directory or its subdirectories.
Despite that, files were organized into subdirectories to group them logically and reduce the size of the main directory.
The project directory is divided into three subdirectories: \texttt{assets}, \texttt{scenes}, and \texttt{scripts}.
Visually, the project file structure looks like:
\dirtree{%
.1 GeoApp.
.2 assets.
.2 scenes.
.2 scripts.
}

\begin{itemize}
    \item \texttt{assets} contains non-code resources used by the application, such as icons, and the application's theme.
    \item \texttt{scenes} contains Godot scene files, which define the structure and composition of the user interface and 3D objects.
    \item \texttt{scripts} contains script files implementing the application logic, including input handling and geometric calculations.
\end{itemize}
This structure improves clarity and simplifies project navigation.

% \begin{itemize}
% \item concept of the system
% \item system architecture
% \item description of data structures (and data bases)
% \item components, modules, libraries, resume of important classes (if used)
% \item resume of important algorithms (if used)
% \item details of implementation of selected parts
% \item applied design patterns
% \item UML diagrams
% \end{itemize}



% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% To use the minted package, import the package:                    %
% \usepackage{minted}                                               %
% and compile with the shell escape                                 %
% pdflatex -shell-escape main                                       %
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 


% Use special environments for inline code, eg  \lstinline|int a;| (package \texttt{listings})% or  \mintinline{C++}|int a;| (package \texttt{minted})
% . Longer parts of code put in the figure environment, eg. code in Fig. \ref{fig:pseudocode:listings}% and Fig. \ref{fig:pseudocode:minted}
% . Very long listingsâ€“move to an appendix.
%
%
% \clearpage
% \begin{figure}
% \centering
% \begin{lstlisting}
% class test : public basic
% {
%     public:
%       test (int a);
%       friend std::ostream operator<<(std::ostream & s, 
%                                      const test & t);
%     protected:
%       int _a;  
%
% };
% \end{lstlisting}
% \caption{Pseudocode in \texttt{listings}.}
% \label{fig:pseudocode:listings}
% \end{figure}

%\begin{figure}
%\centering
%\begin{minted}[linenos,frame=lines]{c++}
%class test : public basic
%{
%    public:
%      test (int a);
%      friend std::ostream operator<<(std::ostream & s, 
%                                     const test & t);
%    protected:
%      int _a;  
%      
%};
%\end{minted}
%\caption{Pseudocode in \texttt{minted}.}
%\label{fig:pseudocode:minted}
%\end{figure}


