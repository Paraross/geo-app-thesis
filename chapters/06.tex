\chapter{Verification and validation}

The application was tested only by the author.
The application was tested by manually checking whether all implemented features work correctly.
The application was tested on a laptop device with the following software and hardware configuration:

\bigskip

\begin{tabularx}{0.9\linewidth}{l X}
    CPU & AMD Ryzen 7 5800H \\
    GPU & NVIDIA GeForce RTX 3050 \\
    RAM & 16 GB \\
    Operating system & Windows 11 \\
\end{tabularx}

\section{Found and fixed bugs}

\subsection{Unintentional camera zooming}

While testing the camera movement, a bug was found when opposite movement keys were pressed simultaneously.
In this situation, the camera zoomed in toward the origin at a slow rate.

The issue was caused by an incorrect implementation of camera movement logic.
% The original implementation added multiple position changes into an intermediate camera position.
% For each movement direction, the rotated position was calculated based off the original camera position.
For each movement direction, a difference (delta) from the original camera position was calculated.
All deltas were then accumulated into the final position.
When opposite movement directions were processed in the same update cycle, their deltas did not cancel out.
This caused the camera position vector to be slightly shorter after the camera movement calculations.

The problem was resolved by modifying the update logic.
In the fixed version, each camera rotation is calculated sequentially.
Changes from previous directions' calculations are included in the subsequent ones.
This approach guarantees that the effects fully cancel out when the camera is moved in opposite directions at the same time.

% TODO: pseudokod?

\begin{lstlisting}[basicstyle=\ttfamily, showstringspaces=false, caption=Original camera movement implementation.]
var next_camera_position := position
if move_up and camera_angle - rotate_amount > -PI / 2.0:
    var left := -Vector3.UP.cross(position).normalized()
    next_camera_position += position.rotated(left, rotate_amount) - position
if move_down and camera_angle + rotate_amount < PI / 2.0:
    var right := Vector3.UP.cross(position).normalized()
    next_camera_position += position.rotated(right, rotate_amount) - position
if move_left:
    next_camera_position += position.rotated(Vector3.DOWN, rotate_amount) - position
if move_right:
    next_camera_position += position.rotated(Vector3.UP, rotate_amount) - position

position = next_camera_position
\end{lstlisting}

\begin{lstlisting}[basicstyle=\ttfamily, showstringspaces=false, caption=Fixed camera movement implementation.]
if move_up and camera_angle - rotate_amount > -PI / 2.0:
    var left := Vector3.DOWN.cross(position).normalized()
    position = position.rotated(left, rotate_amount)
if move_down and camera_angle + rotate_amount < PI / 2.0:
    var right := Vector3.UP.cross(position).normalized()
    position = position.rotated(right, rotate_amount)
if move_left:
    position = position.rotated(Vector3.DOWN, rotate_amount)
if move_right:
    position = position.rotated(Vector3.UP, rotate_amount)

\end{lstlisting}

% \subsection{Incorrect informational label positioning and }
\subsection{Issues related to edge cylinder transform}

A bug was discovered when testing solids whose center was sufficiently far away from the origin.
The bug caused the informational labels to be in incorrect positions.
Vertical edge cylinders were visibly thinner compared to the rest.

The issue was caused by an incorrect implementation of the edge cylinder positioning logic.
The label's position is calculated as an extension of the edge cylinder's \textit{right vector}.
The right vector is the normal vector in the object's local coordinate system.


% \begin{itemize}
% \item testing paradigm (eg V model)
% \item test cases, testing scope (full / partial)
% \item detected and fixed bugs
%     % TODO: concave poly na scianach
% \item results of experiments (optional)
% \end{itemize}
%
%
% \begin{table}
% \centering
% \caption{A caption of a table is \textbf{above} it.}
% \label{id:tab:wyniki}
% \begin{tabular}{rrrrrrrr}
% \toprule
% 	         &                                     \multicolumn{7}{c}{method}                                      \\
% 	         \cmidrule{2-8}
% 	         &         &         &        \multicolumn{3}{c}{alg. 3}        & \multicolumn{2}{c}{alg. 4, $\gamma = 2$} \\
% 	         \cmidrule(r){4-6}\cmidrule(r){7-8}
% 	$\zeta$ &     alg. 1 &   alg. 2 & $\alpha= 1.5$ & $\alpha= 2$ & $\alpha= 3$ &   $\beta = 0.1$  &   $\beta = -0.1$ \\
% \midrule
% 	       0 &  8.3250 & 1.45305 &       7.5791 &    14.8517 &    20.0028 & 1.16396 &                       1.1365 \\
% 	       5 &  0.6111 & 2.27126 &       6.9952 &    13.8560 &    18.6064 & 1.18659 &                       1.1630 \\
% 	      10 & 11.6126 & 2.69218 &       6.2520 &    12.5202 &    16.8278 & 1.23180 &                       1.2045 \\
% 	      15 &  0.5665 & 2.95046 &       5.7753 &    11.4588 &    15.4837 & 1.25131 &                       1.2614 \\
% 	      20 & 15.8728 & 3.07225 &       5.3071 &    10.3935 &    13.8738 & 1.25307 &                       1.2217 \\
% 	      25 &  0.9791 & 3.19034 &       5.4575 &     9.9533 &    13.0721 & 1.27104 &                       1.2640 \\
% 	      30 &  2.0228 & 3.27474 &       5.7461 &     9.7164 &    12.2637 & 1.33404 &                       1.3209 \\
% 	      35 & 13.4210 & 3.36086 &       6.6735 &    10.0442 &    12.0270 & 1.35385 &                       1.3059 \\
% 	      40 & 13.2226 & 3.36420 &       7.7248 &    10.4495 &    12.0379 & 1.34919 &                       1.2768 \\
% 	      45 & 12.8445 & 3.47436 &       8.5539 &    10.8552 &    12.2773 & 1.42303 &                       1.4362 \\
% 	      50 & 12.9245 & 3.58228 &       9.2702 &    11.2183 &    12.3990 & 1.40922 &                       1.3724 \\
% \bottomrule
% \end{tabular}
% \end{table}  
