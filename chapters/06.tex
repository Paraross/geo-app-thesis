\chapter{Verification and validation}

Testing is an important part of the software development process.
Software testing is a process whose goal is to make sure that the tested software behaves as intended \cite{myers2011testing}.
% Its purpose is to detect bugs and verify that the software fulfills its specified requirements.
Testing helps ensure that the system behaves as expected under both normal and exceptional conditions.

Software testing can be divided into several categories, such as unit testing, integration testing, and system testing \cite{gfg_testing}.
In addition, user-oriented testing focuses on validating usability and overall behavior of the application.

Due to the scope and nature of the project, testing mainly focused on system testing and manual testing of the application functionality.
Testing was performed iteratively throughout the development.
Individual features were tested after being implemented to verify that they function correctly and do not break existing functionality.

The application was tested only by the author of the thesis.
Due to limited access to other devices, the application was only tested on a laptop device with the following software and hardware configuration:

\bigskip

\begin{tabularx}{0.9\linewidth}{l X}
    CPU & AMD Ryzen 7 5800H \\
    GPU & NVIDIA GeForce RTX 3050 \\
    RAM & 16 GB \\
    Operating system & Windows 11 \\
\end{tabularx}

\section{Identified bugs}

During testing, several bugs were identified and resolved.
This section describes selected bugs that were discovered, their causes, and the applied fixes.

\subsection{Unintentional camera zooming}

While testing the camera movement, a bug was found when opposite movement keys were pressed simultaneously.
In this situation, the camera zoomed in toward the origin at a slow rate.

The issue was caused by an incorrect implementation of camera movement logic.
% The original implementation added multiple position changes into an intermediate camera position.
% For each movement direction, the rotated position was calculated based off the original camera position.
For each movement direction, a difference (delta) from the original camera position was calculated.
All deltas were then accumulated into the final position.
When opposite movement directions were processed in the same update cycle, their deltas did not cancel out.
This caused the camera position vector to be slightly shorter after the camera movement calculations.

The problem was resolved by modifying the update logic.
In the fixed version, each camera rotation is calculated sequentially.
Changes from previous directions' calculations are included in the subsequent ones.
This approach guarantees that the effects fully cancel out when the camera is moved in opposite directions at the same time.

% TODO: pseudokod?

\begin{lstlisting}[basicstyle=\ttfamily, showstringspaces=false, caption=Original camera movement implementation.]
var next_camera_position := position
if move_up and camera_angle - rotate_amount > -PI / 2.0:
    var left := -Vector3.UP.cross(position).normalized()
    next_camera_position += position.rotated(left, rotate_amount) - position
if move_down and camera_angle + rotate_amount < PI / 2.0:
    var right := Vector3.UP.cross(position).normalized()
    next_camera_position += position.rotated(right, rotate_amount) - position
if move_left:
    next_camera_position += position.rotated(Vector3.DOWN, rotate_amount) - position
if move_right:
    next_camera_position += position.rotated(Vector3.UP, rotate_amount) - position

position = next_camera_position
\end{lstlisting}

\begin{lstlisting}[basicstyle=\ttfamily, showstringspaces=false, caption=Fixed camera movement implementation.]
if move_up and camera_angle - rotate_amount > -PI / 2.0:
    var left := Vector3.DOWN.cross(position).normalized()
    position = position.rotated(left, rotate_amount)
if move_down and camera_angle + rotate_amount < PI / 2.0:
    var right := Vector3.UP.cross(position).normalized()
    position = position.rotated(right, rotate_amount)
if move_left:
    position = position.rotated(Vector3.DOWN, rotate_amount)
if move_right:
    position = position.rotated(Vector3.UP, rotate_amount)
\end{lstlisting}

\subsection{Issues related to edge cylinder transform}

A bug was discovered when testing a polyhedron whose center was sufficiently far away from the origin.
The bug caused the informational labels to be in incorrect positions.
Vertical edge cylinders were visibly thinner compared to the rest.

The issue was caused by an incorrect implementation of the edge cylinder rotation logic.
The rotation of an edge cylinder is set using a 3x3 basis matrix.
Originally, the basis matrix was calculated with the assumption that the center of the polyhedron was in the origin of the global coordinate system.
The result appeared correct for solids whose center was close to the origin of the global coordinate system.
As the solid got further away from the origin, the error became more apparent.

The bug was fixed by correctly calculating the center of the polyhedron.
In the fixed version, the center of the polyhedron is calculated as the average position of all of its vertices.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{graf/testing/basis_pre}
    \caption{Before the fix. Labels appear in incorrect positions. Vertical edges of the top cube are slightly thinner than the rest.}
    \label{basis_pre}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{graf/testing/basis_post}
    \caption{After the fix.}
    \label{basis_post}
\end{figure}

% \begin{itemize}
% \item testing paradigm (eg V model)
% \item test cases, testing scope (full / partial)
% \item detected and fixed bugs
%     % TODO: concave poly na scianach
% \item results of experiments (optional)
% \end{itemize}
%
%
% \begin{table}
% \centering
% \caption{A caption of a table is \textbf{above} it.}
% \label{id:tab:wyniki}
% \begin{tabular}{rrrrrrrr}
% \toprule
% 	         &                                     \multicolumn{7}{c}{method}                                      \\
% 	         \cmidrule{2-8}
% 	         &         &         &        \multicolumn{3}{c}{alg. 3}        & \multicolumn{2}{c}{alg. 4, $\gamma = 2$} \\
% 	         \cmidrule(r){4-6}\cmidrule(r){7-8}
% 	$\zeta$ &     alg. 1 &   alg. 2 & $\alpha= 1.5$ & $\alpha= 2$ & $\alpha= 3$ &   $\beta = 0.1$  &   $\beta = -0.1$ \\
% \midrule
% 	       0 &  8.3250 & 1.45305 &       7.5791 &    14.8517 &    20.0028 & 1.16396 &                       1.1365 \\
% 	       5 &  0.6111 & 2.27126 &       6.9952 &    13.8560 &    18.6064 & 1.18659 &                       1.1630 \\
% 	      10 & 11.6126 & 2.69218 &       6.2520 &    12.5202 &    16.8278 & 1.23180 &                       1.2045 \\
% 	      15 &  0.5665 & 2.95046 &       5.7753 &    11.4588 &    15.4837 & 1.25131 &                       1.2614 \\
% 	      20 & 15.8728 & 3.07225 &       5.3071 &    10.3935 &    13.8738 & 1.25307 &                       1.2217 \\
% 	      25 &  0.9791 & 3.19034 &       5.4575 &     9.9533 &    13.0721 & 1.27104 &                       1.2640 \\
% 	      30 &  2.0228 & 3.27474 &       5.7461 &     9.7164 &    12.2637 & 1.33404 &                       1.3209 \\
% 	      35 & 13.4210 & 3.36086 &       6.6735 &    10.0442 &    12.0270 & 1.35385 &                       1.3059 \\
% 	      40 & 13.2226 & 3.36420 &       7.7248 &    10.4495 &    12.0379 & 1.34919 &                       1.2768 \\
% 	      45 & 12.8445 & 3.47436 &       8.5539 &    10.8552 &    12.2773 & 1.42303 &                       1.4362 \\
% 	      50 & 12.9245 & 3.58228 &       9.2702 &    11.2183 &    12.3990 & 1.40922 &                       1.3724 \\
% \bottomrule
% \end{tabular}
% \end{table}  
